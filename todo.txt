_________________________________________________________________________________________________

TODO:
_________________________________________________________________________________________________

* Parameterized InternetOpenUrl flags
* Parameterized HttpSendRequest flags
* Proxy
* reconnect during dld
* Connect timeout parameter
* Reconnect timeout parameter
* Resume
- Resume the downloads to memory, as well
* query file size
* download file with unknown size
- HTTP/HTTPS authentication?
- PROXY authentication?
- PUT(WebDAV)
* POST headers
- Multiple download sources
* Support files > 4GB
- Support destination folder only. Use the filename from HTTP_QUERY_CONTENT_DISPOSITION (ex: piriform downloads)
* Use InternetSetStatusCallback (remember last status, remember server IP)
- Retry opening local file if ERROR_LOCK_VIOLATION
- Download to temporary file
* Measure transfer speed
* Save the raw headers and make them available for querying
- Queue priorities
* Enumerate transfers in queue
- Pause/Resume transfer. Create paused
- Abort transfer
- Attach the "Zone.Identifier" stream (optional)
- Support for NSIS script to retrieve the content of MEMORY files
- All functions with variable number of arguments must receive /END
* NSdown::Query return time information (elapsed waiting, elapsed transferring, etc)
- NSdown::QueryGlobal converted to receive variable number of arguments + /END