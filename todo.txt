_________________________________________________________________________________________________

TODO:
_________________________________________________________________________________________________

* Parameterized InternetOpenUrl flags
* Parameterized HttpSendRequest flags
* Proxy
* reconnect during dld
* Connect timeout parameter
* Reconnect timeout parameter
* Resume
* Resume memory downloads as well
* query file size
* download file with unknown size
- HTTP/HTTPS authentication?
- PROXY authentication?
- PUT(WebDAV)
* POST headers
- Multiple download sources
* Support files > 4GB
- Support destination folder only. Use the filename from HTTP_QUERY_CONTENT_DISPOSITION (ex: piriform downloads)
* Use InternetSetStatusCallback (remember last status, remember server IP)
* Retry opening local file if ERROR_LOCK_VIOLATION
- Download to temporary file
* Measure transfer speed
* Save the raw headers and make them available for querying
- Queue priorities
* Enumerate transfers in queue
- Pause/Resume transfer. Create paused
- Abort transfer
- Attach the "Zone.Identifier" stream (optional)
* Support for the NSIS script to retrieve memory content
* All functions with variable number of arguments must receive /END
* NSdown::Query return time information (elapsed waiting, elapsed transferring, etc)
* NSdown::QueryGlobal converted to receive variable number of arguments + /END
- Configurable: worker threads, NSDOWN_USERAGENT, TRANSFER_CHUNK_SIZE, MAX_MEMORY_CONTENT_LENGTH, CONNECT_RETRY_DELAY, SPEED_MEASURE_INTERVAL
- Transfer GUI